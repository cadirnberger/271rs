{
  "latest": {
    "/mnt/c/Users/caden/271rs/final/src/main.rs": [
      "use serde::{Deserialize, Serialize};",
      "use similar::TextDiff;",
      "use std::collections::HashMap;",
      "use std::fs;",
      "use std::path::Path;",
      "use walkdir::WalkDir;",
      "use std::process::Command;",
      "",
      "static SCM_NAME: &str = \".scm\";",
      "static DIFF_NAME: &str = \".diff\";",
      "",
      "type FileMap = HashMap<String, Vec<String>>;",
      "",
      "fn read_lines(path: &str) -> Vec<String> {",
      "    let p = Path::new(path);",
      "    if !p.is_file() {",
      "        return vec![]; // skip directories",
      "    }",
      "    fs::read_to_string(p)",
      "        .unwrap_or_else(|_| \"\".to_string())",
      "        .lines()",
      "        .map(|s| s.to_string())",
      "        .collect()",
      "}",
      "",
      "fn write_lines(path: &str, lines: &[String]) {",
      "    fs::write(path, lines.join(\"\\n\")).unwrap();",
      "}",
      "",
      "fn diff_lines(a: &[String], b: &[String]) -> Vec<String> {",
      "    let a_join = a.join(\"\\n\");",
      "    let b_join = b.join(\"\\n\");",
      "",
      "    let diff = TextDiff::from_lines(&a_join, &b_join);",
      "    let mut out = Vec::new();",
      "",
      "    for hunk in diff.unified_diff().iter_hunks() {",
      "        for line in hunk.to_string().lines() {",
      "            out.push(line.trim_end().to_string());",
      "        }",
      "    }",
      "",
      "    out",
      "}",
      "",
      "fn collect_visible_files() -> Vec<String> {",
      "    let cwd = std::env::current_dir().unwrap();",
      "",
      "    WalkDir::new(cwd)",
      "        .into_iter()",
      "        .filter_map(|e| e.ok())",
      "        .filter(|e| e.file_type().is_file())",
      "        .filter(|e| !e.path().to_string_lossy().contains(\"/.\"))",
      "        .map(|e| e.path().to_string_lossy().to_string())",
      "        .collect()",
      "}",
      "",
      "#[derive(Serialize, Deserialize)]",
      "struct CommitEntry {",
      "    init: FileMap,",
      "    diff: HashMap<String, Vec<String>>,",
      "}",
      "",
      "#[derive(Serialize, Deserialize)]",
      "struct SCMFile {",
      "    latest: FileMap,",
      "    commit: Vec<CommitEntry>,",
      "}",
      "",
      "fn load_scm() -> Option<SCMFile> {",
      "    if !Path::new(SCM_NAME).exists() {",
      "        return None;",
      "    }",
      "    let s = fs::read_to_string(SCM_NAME).ok()?;",
      "    serde_json::from_str(&s).ok()",
      "}",
      "",
      "fn save_scm(scm: &SCMFile) {",
      "    fs::write(SCM_NAME, serde_json::to_string_pretty(scm).unwrap()).unwrap();",
      "}",
      "",
      "fn command_commit() {",
      "    let files = collect_visible_files();",
      "",
      "    let mut scm_opt = load_scm();",
      "",
      "    if scm_opt.is_none() {",
      "        // First commit",
      "        let mut latest = FileMap::new();",
      "        for f in &files {",
      "            latest.insert(f.clone(), read_lines(f));",
      "        }",
      "",
      "        let commit = CommitEntry {",
      "            init: latest.clone(),",
      "            diff: HashMap::new(),",
      "        };",
      "",
      "        let new_scm = SCMFile {",
      "            latest,",
      "            commit: vec![commit],",
      "        };",
      "",
      "        save_scm(&new_scm);",
      "        return;",
      "    }",
      "",
      "    let mut scm = scm_opt.unwrap();",
      "",
      "    let last = scm.commit.last().unwrap();",
      "",
      "    let old_fs: Vec<String> = last",
      "        .init",
      "        .keys()",
      "        .chain(last.diff.keys())",
      "        .cloned()",
      "        .collect();",
      "",
      "    let new_fs: Vec<String> = files",
      "        .iter()",
      "        .filter(|f| !old_fs.contains(f.clone()))",
      "        .cloned()",
      "        .collect();",
      "",
      "    let mut init = FileMap::new();",
      "    for f in &new_fs {",
      "        init.insert(f.clone(), read_lines(f));",
      "    }",
      "",
      "    let mut diff = HashMap::new();",
      "    for f in &old_fs {",
      "        let before = scm.latest.get(f).unwrap_or(&vec![]).to_vec();",
      "        let after = read_lines(f);",
      "        diff.insert(f.clone(), diff_lines(&before, &after));",
      "    }",
      "",
      "    let mut new_latest = FileMap::new();",
      "    for f in &files {",
      "        new_latest.insert(f.clone(), read_lines(f));",
      "    }",
      "    scm.latest = new_latest;",
      "",
      "    scm.commit.push(CommitEntry { init, diff });",
      "",
      "    save_scm(&scm);",
      "}",
      "",
      "fn command_scrape() {",
      "    let scm = match load_scm() {",
      "        Some(s) => s,",
      "        None => return,",
      "    };",
      "",
      "    for (path, lines) in scm.latest {",
      "        write_lines(&path, &lines);",
      "    }",
      "}",
      "",
      "fn command_revert() {",
      "    command_scrape();",
      "",
      "    let mut scm = match load_scm() {",
      "        Some(s) => s,",
      "        None => return,",
      "    };",
      "",
      "    if scm.commit.len() < 2 {",
      "        return;",
      "    }",
      "",
      "    let last = scm.commit.pop().unwrap();",
      "    let diffs = last.diff;",
      "",
      "    for (file, diff_lines_vec) in diffs {",
      "        write_lines(DIFF_NAME, &diff_lines_vec);",
      "",
      "        Command::new(\"patch\")",
      "            .arg(\"-R\")",
      "            .arg(&file)",
      "            .arg(DIFF_NAME)",
      "            .status()",
      "            .unwrap();",
      "    }",
      "",
      "    save_scm(&scm);",
      "    let _ = fs::remove_file(DIFF_NAME);",
      "}",
      "",
      "fn command_viewer() {",
      "    Command::new(\"jq\")",
      "        .arg(\".\")",
      "        .arg(SCM_NAME)",
      "        .status()",
      "        .unwrap();",
      "}",
      "",
      "fn main() {",
      "    let args: Vec<String> = std::env::args().collect();",
      "",
      "    if args.len() != 2 {",
      "        eprintln!(\"Usage: scm <commit|scrape|revert|viewer>\");",
      "        return;",
      "    }",
      "",
      "    match args[1].as_str() {",
      "        \"commit\" => command_commit(),",
      "        \"scrape\" => command_scrape(),",
      "        \"revert\" => command_revert(),",
      "        \"viewer\" => command_viewer(),",
      "        _ => eprintln!(\"Unknown command\"),",
      "    }",
      "}",
      ""
    ]
  },
  "commit": [
    {
      "init": {
        "/mnt/c/Users/caden/271rs/final/src/main.rs": [
          "use serde::{Deserialize, Serialize};",
          "use similar::TextDiff;",
          "use std::collections::HashMap;",
          "use std::fs;",
          "use std::path::Path;",
          "use walkdir::WalkDir;",
          "use std::process::Command;",
          "",
          "static SCM_NAME: &str = \".scm\";",
          "static DIFF_NAME: &str = \".diff\";",
          "",
          "type FileMap = HashMap<String, Vec<String>>;",
          "",
          "fn read_lines(path: &str) -> Vec<String> {",
          "    let p = Path::new(path);",
          "    if !p.is_file() {",
          "        return vec![]; // skip directories",
          "    }",
          "    fs::read_to_string(p)",
          "        .unwrap_or_else(|_| \"\".to_string())",
          "        .lines()",
          "        .map(|s| s.to_string())",
          "        .collect()",
          "}",
          "",
          "fn write_lines(path: &str, lines: &[String]) {",
          "    fs::write(path, lines.join(\"\\n\")).unwrap();",
          "}",
          "",
          "fn diff_lines(a: &[String], b: &[String]) -> Vec<String> {",
          "    let a_join = a.join(\"\\n\");",
          "    let b_join = b.join(\"\\n\");",
          "",
          "    let diff = TextDiff::from_lines(&a_join, &b_join);",
          "    let mut out = Vec::new();",
          "",
          "    for hunk in diff.unified_diff().iter_hunks() {",
          "        for line in hunk.to_string().lines() {",
          "            out.push(line.trim_end().to_string());",
          "        }",
          "    }",
          "",
          "    out",
          "}",
          "",
          "fn collect_visible_files() -> Vec<String> {",
          "    let cwd = std::env::current_dir().unwrap();",
          "",
          "    WalkDir::new(cwd)",
          "        .into_iter()",
          "        .filter_map(|e| e.ok())",
          "        .filter(|e| e.file_type().is_file())",
          "        .filter(|e| !e.path().to_string_lossy().contains(\"/.\"))",
          "        .map(|e| e.path().to_string_lossy().to_string())",
          "        .collect()",
          "}",
          "",
          "#[derive(Serialize, Deserialize)]",
          "struct CommitEntry {",
          "    init: FileMap,",
          "    diff: HashMap<String, Vec<String>>,",
          "}",
          "",
          "#[derive(Serialize, Deserialize)]",
          "struct SCMFile {",
          "    latest: FileMap,",
          "    commit: Vec<CommitEntry>,",
          "}",
          "",
          "fn load_scm() -> Option<SCMFile> {",
          "    if !Path::new(SCM_NAME).exists() {",
          "        return None;",
          "    }",
          "    let s = fs::read_to_string(SCM_NAME).ok()?;",
          "    serde_json::from_str(&s).ok()",
          "}",
          "",
          "fn save_scm(scm: &SCMFile) {",
          "    fs::write(SCM_NAME, serde_json::to_string_pretty(scm).unwrap()).unwrap();",
          "}",
          "",
          "fn command_commit() {",
          "    let files = collect_visible_files();",
          "",
          "    let mut scm_opt = load_scm();",
          "",
          "    if scm_opt.is_none() {",
          "        // First commit",
          "        let mut latest = FileMap::new();",
          "        for f in &files {",
          "            latest.insert(f.clone(), read_lines(f));",
          "        }",
          "",
          "        let commit = CommitEntry {",
          "            init: latest.clone(),",
          "            diff: HashMap::new(),",
          "        };",
          "",
          "        let new_scm = SCMFile {",
          "            latest,",
          "            commit: vec![commit],",
          "        };",
          "",
          "        save_scm(&new_scm);",
          "        return;",
          "    }",
          "",
          "    let mut scm = scm_opt.unwrap();",
          "",
          "    let last = scm.commit.last().unwrap();",
          "",
          "    let old_fs: Vec<String> = last",
          "        .init",
          "        .keys()",
          "        .chain(last.diff.keys())",
          "        .cloned()",
          "        .collect();",
          "",
          "    let new_fs: Vec<String> = files",
          "        .iter()",
          "        .filter(|f| !old_fs.contains(f.clone()))",
          "        .cloned()",
          "        .collect();",
          "",
          "    let mut init = FileMap::new();",
          "    for f in &new_fs {",
          "        init.insert(f.clone(), read_lines(f));",
          "    }",
          "",
          "    let mut diff = HashMap::new();",
          "    for f in &old_fs {",
          "        let before = scm.latest.get(f).unwrap_or(&vec![]).to_vec();",
          "        let after = read_lines(f);",
          "        diff.insert(f.clone(), diff_lines(&before, &after));",
          "    }",
          "",
          "    let mut new_latest = FileMap::new();",
          "    for f in &files {",
          "        new_latest.insert(f.clone(), read_lines(f));",
          "    }",
          "    scm.latest = new_latest;",
          "",
          "    scm.commit.push(CommitEntry { init, diff });",
          "",
          "    save_scm(&scm);",
          "}",
          "",
          "fn command_scrape() {",
          "    let scm = match load_scm() {",
          "        Some(s) => s,",
          "        None => return,",
          "    };",
          "",
          "    for (path, lines) in scm.latest {",
          "        write_lines(&path, &lines);",
          "    }",
          "}",
          "",
          "fn command_revert() {",
          "    command_scrape();",
          "",
          "    let mut scm = match load_scm() {",
          "        Some(s) => s,",
          "        None => return,",
          "    };",
          "",
          "    if scm.commit.len() < 2 {",
          "        return;",
          "    }",
          "",
          "    let last = scm.commit.pop().unwrap();",
          "    let diffs = last.diff;",
          "",
          "    for (file, diff_lines_vec) in diffs {",
          "        write_lines(DIFF_NAME, &diff_lines_vec);",
          "",
          "        Command::new(\"patch\")",
          "            .arg(\"-R\")",
          "            .arg(&file)",
          "            .arg(DIFF_NAME)",
          "            .status()",
          "            .unwrap();",
          "    }",
          "",
          "    save_scm(&scm);",
          "    let _ = fs::remove_file(DIFF_NAME);",
          "}",
          "",
          "fn command_viewer() {",
          "    Command::new(\"jq\")",
          "        .arg(\".\")",
          "        .arg(SCM_NAME)",
          "        .status()",
          "        .unwrap();",
          "}",
          "",
          "fn main() {",
          "    let args: Vec<String> = std::env::args().collect();",
          "",
          "    if args.len() != 2 {",
          "        eprintln!(\"Usage: scm <commit|scrape|revert|viewer>\");",
          "        return;",
          "    }",
          "",
          "    match args[1].as_str() {",
          "        \"commit\" => command_commit(),",
          "        \"scrape\" => command_scrape(),",
          "        \"revert\" => command_revert(),",
          "        \"viewer\" => command_viewer(),",
          "        _ => eprintln!(\"Unknown command\"),",
          "    }",
          "}",
          ""
        ]
      },
      "diff": {}
    },
    {
      "init": {},
      "diff": {
        "/mnt/c/Users/caden/271rs/final/src/main.rs": []
      }
    },
    {
      "init": {},
      "diff": {
        "/mnt/c/Users/caden/271rs/final/src/main.rs": []
      }
    }
  ]
}